<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vector Transformation Program</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f0f0;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        canvas {
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .action-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            margin: 5px 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        select {
            padding: 8px;
            margin: 5px;
        }

        .status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Vector Transformation Program</h1>

        <div class="canvas-container">
            <canvas id="sourceCanvas" width="400" height="400"></canvas>
            <canvas id="resultCanvas" width="400" height="400"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <button id="clearSource">Clear Source</button>
                <button id="clearTarget">Clear Target</button>
                <button id="undo">Undo Last Point</button>
            </div>

            <div class="control-group">
                <label>Transformation Method:</label>
                <select id="method">
                    <option value="mapper">Mapper</option>
                    <option value="ganger">Ganger</option>
                    <option value="shadow">Shadow</option>
                </select>
            </div>

            <div class="control-group">
                <label>Number of Intermediate Frames:</label>
                <input type="range" id="frames" min="1" max="50" value="20">
                <span id="frameCount">20</span>
            </div>

            <div class="control-group action-row">
                <button id="transform">Transform</button>
                <button id="animate">Animate</button>
                <button id="stop">Stop</button>
            </div>

            <div class="control-group action-row">
                <button id="downloadResult">Download result as PNG</button>
                <button onclick="openMuseumText()" aria-label="Open museum text">Open museum text</button>
            </div>

            <div class="status" id="status">
                Draw shapes on both canvases, then click Transform
            </div>
        </div>
    </div>

    <script>
        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            static interpolate(v1, v2, t) {
                return new Vector(
                    v1.x + (v2.x - v1.x) * t,
                    v1.y + (v2.y - v1.y) * t
                );
            }
        }

        class Shape {
            constructor() {
                this.points = [];
                this.vectors = [];
            }

            addPoint(x, y) {
                this.points.push(new Vector(x, y));
                this.updateVectors();
            }

            updateVectors() {
                if (this.points.length < 2) return;

                this.vectors = [];
                for (let i = 1; i < this.points.length; i++) {
                    this.vectors.push({
                        start: this.points[i-1],
                        end: this.points[i]
                    });
                }
            }

            draw(ctx) {
                if (this.points.length === 0) return;

                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }

                ctx.stroke();

                this.points.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = index === 0 ? 'green' : 'red';
                    ctx.fill();
                });
            }
        }

        class TransformationProgram {
            constructor() {
                this.sourceShape = new Shape();
                this.targetShape = new Shape();
                this.currentFrame = 0;
                this.frames = [];
                this.animationId = null;

                this.setupCanvases();
                this.setupControls();
            }

            setupCanvases() {
                this.sourceCanvas = document.getElementById('sourceCanvas');
                this.resultCanvas = document.getElementById('resultCanvas');
                this.sourceCtx = this.sourceCanvas.getContext('2d');
                this.resultCtx = this.resultCanvas.getContext('2d');

                const addPoint = (canvas, event) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;

                    if (canvas === this.sourceCanvas) {
                        this.sourceShape.addPoint(x, y);
                        this.redrawCanvas(this.sourceCtx, this.sourceShape);
                    } else {
                        this.targetShape.addPoint(x, y);
                        this.redrawCanvas(this.resultCtx, this.targetShape);
                    }
                };

                [this.sourceCanvas, this.resultCanvas].forEach(canvas => {
                    canvas.addEventListener('click', (e) => addPoint(canvas, e));
                });
            }

            setupControls() {
                document.getElementById('clearSource').onclick = () => {
                    this.sourceShape = new Shape();
                    this.redrawCanvas(this.sourceCtx, this.sourceShape);
                };

                document.getElementById('clearTarget').onclick = () => {
                    this.targetShape = new Shape();
                    this.redrawCanvas(this.resultCtx, this.targetShape);
                };

                document.getElementById('transform').onclick = () => this.transform();
                document.getElementById('animate').onclick = () => this.startAnimation();
                document.getElementById('stop').onclick = () => this.stopAnimation();

                document.getElementById('frames').oninput = (e) => {
                    document.getElementById('frameCount').textContent = e.target.value;
                };

                document.getElementById('undo').onclick = () => {
                    if (this.sourceShape.points.length > 0) {
                        this.sourceShape.points.pop();
                        this.sourceShape.updateVectors();
                        this.redrawCanvas(this.sourceCtx, this.sourceShape);
                    }
                };

                document.getElementById('downloadResult').onclick = () => this.downloadResultPNG();
            }

            redrawCanvas(ctx, shape) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                shape.draw(ctx);
            }

            transform() {
                const method = document.getElementById('method').value;
                const frameCount = parseInt(document.getElementById('frames').value);

                if (this.sourceShape.points.length < 2 || this.targetShape.points.length < 2) {
                    document.getElementById('status').textContent = 'Both shapes need at least 2 points';
                    return;
                }

                this.frames = [];

                for (let i = 0; i <= frameCount; i++) {
                    const t = i / frameCount;
                    const frame = new Shape();

                    const sourcePoints = this.sourceShape.points;
                    const targetPoints = this.targetShape.points;

                    let interpolatedPoints;
                    switch(method) {
                        case 'mapper':
                            interpolatedPoints = this.mapperMethod(sourcePoints, targetPoints, t);
                            break;
                        case 'ganger':
                            interpolatedPoints = this.gangerMethod(sourcePoints, targetPoints, t);
                            break;
                        case 'shadow':
                            interpolatedPoints = this.shadowMethod(sourcePoints, targetPoints, t);
                            break;
                    }

                    frame.points = interpolatedPoints;
                    frame.updateVectors();
                    this.frames.push(frame);
                }

                this.currentFrame = 0;
                this.drawFrame(this.currentFrame);
            }

            mapperMethod(sourcePoints, targetPoints, t) {
                const maxPoints = Math.max(sourcePoints.length, targetPoints.length);
                const points = [];

                for (let i = 0; i < maxPoints; i++) {
                    const sourcePoint = sourcePoints[Math.min(i, sourcePoints.length - 1)];
                    const targetPoint = targetPoints[Math.min(i, targetPoints.length - 1)];
                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            gangerMethod(sourcePoints, targetPoints, t) {
                const maxPoints = Math.max(sourcePoints.length, targetPoints.length);
                const points = [];

                for (let i = 0; i < maxPoints; i++) {
                    let sourcePoint = sourcePoints[i] || sourcePoints[sourcePoints.length - 1];
                    let targetPoint = targetPoints[i] || targetPoints[targetPoints.length - 1];
                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            shadowMethod(sourcePoints, targetPoints, t) {
                const points = [];
                const sourceLength = this.getShapeLength(sourcePoints);
                const targetLength = this.getShapeLength(targetPoints);
                const numPoints = Math.max(sourcePoints.length, targetPoints.length);

                for (let i = 0; i < numPoints; i++) {
                    const sourceT = i / (sourcePoints.length - 1);
                    const targetT = i / (targetPoints.length - 1);

                    const sourcePoint = this.getPointAtLength(sourcePoints, sourceT * sourceLength);
                    const targetPoint = this.getPointAtLength(targetPoints, targetT * targetLength);

                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            getShapeLength(points) {
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    length += Math.sqrt(dx * dx + dy * dy);
                }
                return length;
            }

            getPointAtLength(points, targetLength) {
                let currentLength = 0;

                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);

                    if (currentLength + segmentLength >= targetLength) {
                        const remainingLength = targetLength - currentLength;
                        const t = remainingLength / segmentLength;
                        return Vector.interpolate(points[i-1], points[i], t);
                    }

                    currentLength += segmentLength;
                }

                return points[points.length - 1];
            }

            drawFrame(frameIndex) {
                if (!this.frames[frameIndex]) return;
                this.redrawCanvas(this.resultCtx, this.frames[frameIndex]);
            }

            startAnimation() {
                if (this.frames.length === 0) {
                    this.transform();
                }

                this.stopAnimation();

                const frameRate = 10;
                const interval = 1000 / frameRate;

                const animate = () => {
                    this.currentFrame = (this.currentFrame + 1) % this.frames.length;
                    this.drawFrame(this.currentFrame);
                    this.animationId = setTimeout(animate, interval);
                };

                this.animationId = setTimeout(animate, interval);
            }

            stopAnimation() {
                if (this.animationId !== null) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                }
            }

            downloadResultPNG() {
                const link = document.createElement('a');
                link.download = 'vector-result.png';
                link.href = this.resultCanvas.toDataURL('image/png');
                link.click();
            }
        }

        // popup opener for museum text
        function openMuseumText() {
            const url = 'transform_text.html'; // place this beside the current file
            const w = Math.min(900, window.screen.width - 100);
            const h = Math.min(700, window.screen.height - 100);
            const left = Math.max(0, Math.round((window.screen.width - w) / 2));
            const top = Math.max(0, Math.round((window.screen.height - h) / 2));
            const features = `popup=yes,scrollbars=yes,resizable=yes,width=${w},height=${h},left=${left},top=${top}`;
            const win = window.open(url, 'VectorTextPanel', features);
            if (!win) window.open(url, '_blank');
            else win.focus();
        }

        window.onload = () => {
            new TransformationProgram();
        };
    </script>
</body>
</html>
