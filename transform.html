<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vector Transformation Program</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: #f0f0f0;
            touch-action: manipulation;
        }

        h1 {
            text-align: center;
            margin: 10px 0 20px 0;
            font-size: 1.3em;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .canvas-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        canvas {
            background: white;
            border: 2px solid #007bff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            touch-action: none;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
        }

        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .action-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 16px;
            margin: 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 15px;
            flex: 1;
            min-width: 100px;
            font-weight: bold;
        }

        button:hover {
            background: #0056b3;
        }

        button:active {
            transform: scale(0.98);
        }

        select, input[type="range"] {
            padding: 10px;
            font-size: 16px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        input[type="range"] {
            padding: 5px;
        }

        .frame-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #frameCount {
            font-weight: bold;
            font-size: 1.1em;
            min-width: 30px;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 0.9em;
            text-align: center;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }

            .canvas-container {
                flex-direction: row;
                gap: 20px;
            }

            .canvas-wrapper {
                flex: 1;
            }

            canvas {
                width: 400px;
                height: 400px;
            }

            .action-row button {
                flex: 0 1 auto;
            }
        }

        @media (max-width: 767px) {
            canvas {
                width: 100%;
                aspect-ratio: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Vector Transformation</h1>

        <div class="controls">
            <div class="control-group action-row">
                <button id="clearSource">Clear Source</button>
                <button id="clearTarget">Clear Target</button>
                <button id="undo">Undo</button>
            </div>

            <div class="control-group">
                <label>Transformation Method:</label>
                <select id="method">
                    <option value="mapper">Mapper</option>
                    <option value="ganger">Ganger</option>
                    <option value="shadow">Shadow</option>
                </select>
            </div>

            <div class="control-group">
                <label>Intermediate Frames:</label>
                <div class="frame-display">
                    <input type="range" id="frames" min="1" max="50" value="20">
                    <span id="frameCount">20</span>
                </div>
            </div>

            <div class="control-group action-row">
                <button id="transform">Transform</button>
                <button id="animate">Animate</button>
                <button id="stop">Stop</button>
            </div>

            <div class="control-group action-row">
                <button id="downloadResult">Download PNG</button>
            
            </div>

            <div class="status" id="status">
                Tap on both canvases to draw shapes, then tap Transform
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="canvas-label">Source Shape</div>
                <canvas id="sourceCanvas" width="400" height="400"></canvas>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-label">Result Shape</div>
                <canvas id="resultCanvas" width="400" height="400"></canvas>
            </div>
        </div>
    </div>

    <script>
        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            static interpolate(v1, v2, t) {
                return new Vector(
                    v1.x + (v2.x - v1.x) * t,
                    v1.y + (v2.y - v1.y) * t
                );
            }
        }

        class Shape {
            constructor() {
                this.points = [];
                this.vectors = [];
            }

            addPoint(x, y) {
                this.points.push(new Vector(x, y));
                this.updateVectors();
            }

            updateVectors() {
                if (this.points.length < 2) return;

                this.vectors = [];
                for (let i = 1; i < this.points.length; i++) {
                    this.vectors.push({
                        start: this.points[i-1],
                        end: this.points[i]
                    });
                }
            }

            draw(ctx, scale = 1) {
                if (this.points.length === 0) return;

                ctx.lineWidth = 2 / scale;
                ctx.strokeStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }

                ctx.stroke();

                this.points.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4 / scale, 0, Math.PI * 2);
                    ctx.fillStyle = index === 0 ? 'green' : 'red';
                    ctx.fill();
                });
            }
        }

        class TransformationProgram {
            constructor() {
                this.sourceShape = new Shape();
                this.targetShape = new Shape();
                this.currentFrame = 0;
                this.frames = [];
                this.animationId = null;

                this.setupCanvases();
                this.setupControls();
            }

            setupCanvases() {
                this.sourceCanvas = document.getElementById('sourceCanvas');
                this.resultCanvas = document.getElementById('resultCanvas');
                this.sourceCtx = this.sourceCanvas.getContext('2d');
                this.resultCtx = this.resultCanvas.getContext('2d');

                const getCoordinates = (canvas, event) => {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    
                    let clientX, clientY;
                    
                    if (event.touches && event.touches.length > 0) {
                        clientX = event.touches[0].clientX;
                        clientY = event.touches[0].clientY;
                    } else {
                        clientX = event.clientX;
                        clientY = event.clientY;
                    }
                    
                    const x = (clientX - rect.left) * scaleX;
                    const y = (clientY - rect.top) * scaleY;
                    
                    return { x, y };
                };

                const addPoint = (canvas, event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    const { x, y } = getCoordinates(canvas, event);

                    console.log('Adding point:', x, y, 'to', canvas === this.sourceCanvas ? 'source' : 'result');

                    if (canvas === this.sourceCanvas) {
                        this.sourceShape.addPoint(x, y);
                        this.redrawCanvas(this.sourceCtx, this.sourceShape);
                        this.updateStatus(`Source: ${this.sourceShape.points.length} points`);
                    } else {
                        this.targetShape.addPoint(x, y);
                        this.redrawCanvas(this.resultCtx, this.targetShape);
                        this.updateStatus(`Target: ${this.targetShape.points.length} points`);
                    }
                };

                [this.sourceCanvas, this.resultCanvas].forEach(canvas => {
                    // Mouse events
                    canvas.addEventListener('click', (e) => {
                        e.preventDefault();
                        addPoint(canvas, e);
                    });
                    
                    // Touch events
                    canvas.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        addPoint(canvas, e);
                    }, { passive: false });
                    
                    // Prevent context menu
                    canvas.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                    });
                });
            }

            setupControls() {
                document.getElementById('clearSource').onclick = () => {
                    this.sourceShape = new Shape();
                    this.redrawCanvas(this.sourceCtx, this.sourceShape);
                    this.updateStatus('Source cleared');
                };

                document.getElementById('clearTarget').onclick = () => {
                    this.targetShape = new Shape();
                    this.redrawCanvas(this.resultCtx, this.targetShape);
                    this.updateStatus('Target cleared');
                };

                document.getElementById('transform').onclick = () => this.transform();
                document.getElementById('animate').onclick = () => this.startAnimation();
                document.getElementById('stop').onclick = () => this.stopAnimation();

                document.getElementById('frames').oninput = (e) => {
                    document.getElementById('frameCount').textContent = e.target.value;
                };

                document.getElementById('undo').onclick = () => {
                    if (this.targetShape.points.length > 0) {
                        this.targetShape.points.pop();
                        this.targetShape.updateVectors();
                        this.redrawCanvas(this.resultCtx, this.targetShape);
                    } else if (this.sourceShape.points.length > 0) {
                        this.sourceShape.points.pop();
                        this.sourceShape.updateVectors();
                        this.redrawCanvas(this.sourceCtx, this.sourceShape);
                    }
                };

                document.getElementById('downloadResult').onclick = () => this.downloadResultPNG();
            }

            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }

            redrawCanvas(ctx, shape) {
                const canvas = ctx.canvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                shape.draw(ctx);
            }

            transform() {
                const method = document.getElementById('method').value;
                const frameCount = parseInt(document.getElementById('frames').value);

                if (this.sourceShape.points.length < 2 || this.targetShape.points.length < 2) {
                    this.updateStatus('Both shapes need at least 2 points');
                    return;
                }

                this.frames = [];

                for (let i = 0; i <= frameCount; i++) {
                    const t = i / frameCount;
                    const frame = new Shape();

                    const sourcePoints = this.sourceShape.points;
                    const targetPoints = this.targetShape.points;

                    let interpolatedPoints;
                    switch(method) {
                        case 'mapper':
                            interpolatedPoints = this.mapperMethod(sourcePoints, targetPoints, t);
                            break;
                        case 'ganger':
                            interpolatedPoints = this.gangerMethod(sourcePoints, targetPoints, t);
                            break;
                        case 'shadow':
                            interpolatedPoints = this.shadowMethod(sourcePoints, targetPoints, t);
                            break;
                    }

                    frame.points = interpolatedPoints;
                    frame.updateVectors();
                    this.frames.push(frame);
                }

                this.currentFrame = 0;
                this.drawFrame(this.currentFrame);
                this.updateStatus(`Transformation complete: ${this.frames.length} frames`);
            }

            mapperMethod(sourcePoints, targetPoints, t) {
                const maxPoints = Math.max(sourcePoints.length, targetPoints.length);
                const points = [];

                for (let i = 0; i < maxPoints; i++) {
                    const sourcePoint = sourcePoints[Math.min(i, sourcePoints.length - 1)];
                    const targetPoint = targetPoints[Math.min(i, targetPoints.length - 1)];
                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            gangerMethod(sourcePoints, targetPoints, t) {
                const maxPoints = Math.max(sourcePoints.length, targetPoints.length);
                const points = [];

                for (let i = 0; i < maxPoints; i++) {
                    let sourcePoint = sourcePoints[i] || sourcePoints[sourcePoints.length - 1];
                    let targetPoint = targetPoints[i] || targetPoints[targetPoints.length - 1];
                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            shadowMethod(sourcePoints, targetPoints, t) {
                const points = [];
                const sourceLength = this.getShapeLength(sourcePoints);
                const targetLength = this.getShapeLength(targetPoints);
                const numPoints = Math.max(sourcePoints.length, targetPoints.length);

                for (let i = 0; i < numPoints; i++) {
                    const sourceT = i / (sourcePoints.length - 1);
                    const targetT = i / (targetPoints.length - 1);

                    const sourcePoint = this.getPointAtLength(sourcePoints, sourceT * sourceLength);
                    const targetPoint = this.getPointAtLength(targetPoints, targetT * targetLength);

                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            getShapeLength(points) {
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    length += Math.sqrt(dx * dx + dy * dy);
                }
                return length;
            }

            getPointAtLength(points, targetLength) {
                let currentLength = 0;

                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);

                    if (currentLength + segmentLength >= targetLength) {
                        const remainingLength = targetLength - currentLength;
                        const t = remainingLength / segmentLength;
                        return Vector.interpolate(points[i-1], points[i], t);
                    }

                    currentLength += segmentLength;
                }

                return points[points.length - 1];
            }

            drawFrame(frameIndex) {
                if (!this.frames[frameIndex]) return;
                this.redrawCanvas(this.resultCtx, this.frames[frameIndex]);
            }

            startAnimation() {
                if (this.frames.length === 0) {
                    this.transform();
                }

                this.stopAnimation();

                const frameRate = 10;
                const interval = 1000 / frameRate;

                const animate = () => {
                    this.currentFrame = (this.currentFrame + 1) % this.frames.length;
                    this.drawFrame(this.currentFrame);
                    this.animationId = setTimeout(animate, interval);
                };

                this.updateStatus('Animation playing...');
                this.animationId = setTimeout(animate, interval);
            }

            stopAnimation() {
                if (this.animationId !== null) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                    this.updateStatus('Animation stopped');
                }
            }

            downloadResultPNG() {
                const link = document.createElement('a');
                link.download = 'vector-result.png';
                link.href = this.resultCanvas.toDataURL('image/png');
                link.click();
            }
        }

        function openMuseumText() {
            const url = 'transform_text.html';
            const w = Math.min(900, window.screen.width - 100);
            const h = Math.min(700, window.screen.height - 100);
            const left = Math.max(0, Math.round((window.screen.width - w) / 2));
            const top = Math.max(0, Math.round((window.screen.height - h) / 2));
            const features = `popup=yes,scrollbars=yes,resizable=yes,width=${w},height=${h},left=${left},top=${top}`;
            const win = window.open(url, 'VectorTextPanel', features);
            if (!win) window.open(url, '_blank');
            else win.focus();
        }

        window.onload = () => {
            new TransformationProgram();
        };
    </script>
</body>
</html>
